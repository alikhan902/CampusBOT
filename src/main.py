import time
import os
import asyncio
import re
import os
import uuid
import json
import requests
import aiohttp
from dotenv import load_dotenv
from bs4 import BeautifulSoup

from aiogram import Bot, Dispatcher, Router, F
from aiogram.types import Message, FSInputFile
from aiogram.fsm.state import StatesGroup, State
from aiogram.fsm.context import FSMContext
from aiogram.filters import Command

from utils import get_monday_date

load_dotenv()

TOKEN = os.getenv("BOT_TOKEN")

bot = Bot(token=TOKEN)
dp = Dispatcher()
router = Router()

# FSM
class AuthForm(StatesGroup):
    login = State()
    password = State()
    captcha_code = State()
    
# /start
@router.message(Command("start"))
async def start_cmd(message: Message, state: FSMContext):
    await login_cmd(message, state)


# /login
@router.message(F.text == "/login")
async def login_cmd(message: Message, state: FSMContext):
    session = requests.Session()
    login_url = "https://ecampus.ncfu.ru/account/login"
    resp = session.get(login_url)
    soup = BeautifulSoup(resp.text, "html.parser")

    token_tag = soup.find("input", {"name": "__RequestVerificationToken"})
    captcha_tag = soup.find("img", {"alt": "captcha"})

    if not token_tag or not captcha_tag:
        await message.answer("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Ç–æ–∫–µ–Ω –∏–ª–∏ –∫–∞–ø—á—É üò¢")
        return

    token = token_tag["value"]
    captcha_url = "https://ecampus.ncfu.ru" + captcha_tag["src"]

    filename = f"captcha_{uuid.uuid4().hex}.jpg"
    filepath = os.path.join("captcha", filename)
    os.makedirs(os.path.dirname(filepath), exist_ok=True)

    captcha_resp = session.get(captcha_url)
    with open(filepath, "wb") as f:
        f.write(captcha_resp.content)

    # —Å–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–æ–∫–µ–Ω –∏ –∫—É–∫–∏ –≤ FSM
    await state.update_data(
        cookies=session.cookies.get_dict(),
        token=token,
        captcha_filepath=filepath
    )

    await message.answer("–í–≤–µ–¥–∏—Ç–µ –ª–æ–≥–∏–Ω:")
    await state.set_state(AuthForm.login)


# –ª–æ–≥–∏–Ω
@router.message(AuthForm.login)
async def process_login(message: Message, state: FSMContext):
    await state.update_data(login=message.text)
    await message.answer("–í–≤–µ–¥–∏—Ç–µ –ø–∞—Ä–æ–ª—å:")
    await state.set_state(AuthForm.password)

# –ø–∞—Ä–æ–ª—å
@router.message(AuthForm.password)
async def process_password(message: Message, state: FSMContext):
    await state.update_data(password=message.text)
    data = await state.get_data()
    captcha_filepath = data.get("captcha_filepath")
    if captcha_filepath:
        await message.answer_photo(FSInputFile(captcha_filepath), caption="–í–≤–µ–¥–∏—Ç–µ –∫–∞–ø—á—É:")
    await state.set_state(AuthForm.captcha_code)

# –∫–∞–ø—á–∞
@router.message(AuthForm.captcha_code)
async def process_captcha(message: Message, state: FSMContext):
    data = await state.get_data()
    cookies = data["cookies"]
    token = data["token"]

    session = requests.Session()
    session.cookies.update(cookies)

    payload = {
        "__RequestVerificationToken": token,
        "Login": data["login"],
        "Password": data["password"],
        "Code": message.text,
        "RememberMe": "false",
    }

    resp = session.post("https://ecampus.ncfu.ru/account/login", data=payload)
    get_id = session.get("https://ecampus.ncfu.ru/schedule/my/student")
    soup2 = BeautifulSoup(get_id.text, "html.parser")
    script = soup2.find("script", type="text/javascript", string=re.compile("viewModel"))
    print("–æ—Å—Ç–∞–Ω–æ–≤–∫–∞ —Ç—É—Ç 0")

    model_id = None
    if script:
        text = script.string
        match = re.search(r"var\s+viewModel\s*=\s*(\{.*\});", text, re.S)
        print("–æ—Å—Ç–∞–Ω–æ–≤–∫–∞ —Ç—É—Ç 1")
        if match:
            print(match)
            json_text = match.group(1)
            json_text = re.sub(r'JSON\.parse\((\".*?\")\)', r'\1', json_text)
            data_json = json.loads(json_text)
            print(data_json)
            model_id = data_json["Model"]["Id"]
            print("–æ—Å—Ç–∞–Ω–æ–≤–∫–∞ —Ç—É—Ç 2")

    await state.update_data(cookies=session.cookies.get_dict(), ecampus_id=model_id)

    await message.answer(f"–í—Ö–æ–¥ –≤—ã–ø–æ–ª–Ω–µ–Ω ‚úÖ Id={model_id}")
    
    await state.set_state(None)


@router.message(Command("help"))
async def get_schedule(message: Message, state: FSMContext):
    await message.answer("""/login - –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è,\n/schedule - —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–∞ —ç—Ç—É –Ω–µ–¥—É–ª—é,\n/grades - –æ—Ü–µ–Ω–∫–∏ –∏ –ù-–∫–∏""")

# —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ
@router.message(Command("schedule"))
async def get_schedule(message: Message, state: FSMContext):
    data = await state.get_data()
    cookies = data.get("cookies")
    model_id = data.get("ecampus_id")

    monday_date = get_monday_date() 

    payload = {
        "Id": model_id,
        "date": monday_date,
        "targetType": 4
    }

    resp = requests.post(
        "https://ecampus.ncfu.ru/Schedule/GetSchedule",
        cookies=cookies,
        data=payload
    )

    try:
        schedule = resp.json()   # –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ Python-–æ–±—ä–µ–∫—Ç—ã
    except json.JSONDecodeError:
        await message.answer("–û—à–∏–±–∫–∞: —Å–µ—Ä–≤–µ—Ä –≤–µ—Ä–Ω—É–ª –Ω–µ JSON")
        return

    if not schedule:
        await message.answer("–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –ø—É—Å—Ç–æ–µ.")
        return

    text = f"üìÖ –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–∞ –Ω–µ–¥–µ–ª—é —Å {monday_date[:10]}:\n\n"

    for day in schedule:
        weekday = day.get("WeekDay")
        date = day.get("Date")[:10]
        text += f"=== {weekday} ({date}) ===\n"

        lessons = day.get("Lessons", [])
        if not lessons:
            text += "  ‚ùå –ù–µ—Ç –ø–∞—Ä\n\n"
            continue

        for lesson in lessons:
            discipline = lesson.get("Discipline")
            lesson_type = lesson.get("LessonType")
            time_begin = lesson.get("TimeBegin")[11:16]
            time_end = lesson.get("TimeEnd")[11:16]
            if isinstance(lesson, dict):
                teacher = lesson.get("Teacher")
                if isinstance(teacher, dict):
                    teacher_name = teacher.get("Name", "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ")
                else:
                    teacher_name = "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ"
            else:
                teacher_name = "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ"
            print(lesson)
            print(teacher_name)
            aud = lesson.get("Aud", {}).get("Name", "‚Äî")
            group = ", ".join(g["Name"] for g in lesson.get("Groups", []))

            text += (
                f"‚è∞ {time_begin}‚Äì{time_end}\n"
                f"üìñ {discipline} ({lesson_type})\n"
                f"üë®‚Äçüè´ {teacher_name}\n"
                f"üè´ –ê—É–¥–∏—Ç–æ—Ä–∏—è: {aud}\n"
                f"üë• –ì—Ä—É–ø–ø–∞: {group}\n\n"
            )

    for chunk in [text[i:i+4000] for i in range(0, len(text), 4000)]:
        await message.answer(chunk)

@router.message(Command("grades"))
async def get_grades(message: Message, state: FSMContext):
    start_time = time.perf_counter()
    data = await state.get_data()
    cookies = data.get("cookies")
    model_id = data.get("ecampus_id")

    if not model_id or not cookies:
        await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–ø–æ–ª–Ω–∏—Ç–µ –≤—Ö–æ–¥ –≤ —Å–∏—Å—Ç–µ–º—É —Å –ø–æ–º–æ—â—å—é –∫–æ–º–∞–Ω–¥—ã /login.")
        return

    async with aiohttp.ClientSession(cookies=cookies, connector=aiohttp.TCPConnector(limit=5, limit_per_host=3)) as session:
        # --- –ü–æ–ª—É—á–∞–µ–º —Å—Ç—Ä–∞–Ω–∏—Ü—É —Å –∫—É—Ä—Å–∞–º–∏ ---
        async with session.get("https://ecampus.ncfu.ru/studies") as resp:
            text = await resp.text()

        soup = BeautifulSoup(text, "html.parser")
        script = soup.find("script", type="text/javascript", string=re.compile("viewModel"))
        courses = []

        if script:
            text_script = script.string
            match = re.search(r"var\s+viewModel\s*=\s*(\{.*\});", text_script, re.S)
            if match:
                json_text = match.group(1)
                json_text = re.sub(r'JSON\.parse\((\".*?\")\)', r'\1', json_text)
                data_json = json.loads(json_text)
                courses = data_json.get("specialities", [])

        # --- –ò–∑–≤–ª–µ–∫–∞–µ–º model_id –∏–∑ HTML ---
        model_text = text
        last = model_text.rfind('"Id"') + 5
        model_text = model_text[last:]
        first = model_text.find(',')
        model_id = int(model_text[:first])

        all_grades = []
        total_n = 0

        # --- –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫—É—Ä—Å–æ–≤ ---
        for course in courses:
            for year in course.get("AcademicYears", []):
                for term in year.get("Terms", []):
                    if term.get("IsCurrent", False):
                        for course_item in term.get("Courses", []):
                            lesson_types = course_item.get("LessonTypes", [])
                            if not lesson_types:
                                continue

                            total_score = 0
                            total_attendance = 0
                            total_lessons = 0
                            n_count = 0

                            for lesson in lesson_types:
                                lesson_id = lesson.get("Id")

                                payload = {
                                    "studentId": model_id,
                                    "lessonTypeId": lesson_id
                                }

                                async with session.post(
                                    "https://ecampus.ncfu.ru/studies/GetLessons", data=payload
                                ) as grades_resp:
                                    print(resp.status)
                                    if grades_resp.status == 200:
                                        grades = await grades_resp.json()
                                        for grade_info in grades:
                                            attendance = grade_info.get("Attendance")
                                            grade_text = grade_info.get("GradeText")

                                            if attendance == 1:
                                                total_attendance += 1
                                            elif attendance == 0:
                                                n_count += 1

                                            if grade_text:
                                                total_score += {
                                                    "–æ—Ç–ª–∏—á–Ω–æ": 5,
                                                    "—Ö–æ—Ä–æ—à–æ": 4,
                                                    "—É–¥–æ–≤–ª–µ—Ç–≤–æ—Ä–∏—Ç–µ–ª—å–Ω–æ": 3
                                                }.get(grade_text, 0)
                                                total_lessons += 1

                            average_score = total_score / total_lessons if total_lessons > 0 else 0
                            response = (
                                f"–ù–∞–∑–≤–∞–Ω–∏–µ –ø—Ä–µ–¥–º–µ—Ç–∞: {course_item.get('Name')}\n"
                                f"–ù: {n_count}\n"
                                f"–°—Ä–µ–¥–Ω–∏–π –±–∞–ª–ª: {average_score:.2f}"
                            )
                            all_grades.append(response)
                            total_n += n_count

    end_time = time.perf_counter()
    elapsed = end_time - start_time 
    print(f"–í—Ä–µ–º—è {elapsed}")
    # --- –û—Ç–≤–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é ---
    if all_grades:
        response = "\n\n".join(all_grades)
        response += f"\n\n–û–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ù –ø–æ –≤—Å–µ–º –ø—Ä–µ–¥–º–µ—Ç–∞–º: {total_n}"
        await message.answer(response)
    else:
        await message.answer("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –æ –≤–∞—à–∏—Ö –æ—Ü–µ–Ω–∫–∞—Ö.")
        
dp.include_router(router)


async def main():
    await dp.start_polling(bot)

if __name__ == "__main__":
    asyncio.run(main())


